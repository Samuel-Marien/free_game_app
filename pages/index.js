/* eslint-disable @next/next/no-img-element */
import Head from 'next/head'
import { useSession, getSession } from 'next-auth/react'

import { connectToDataBase } from '../lib/db'
import {
  getSuggestedGames,
  getAllGames,
  getGame,
  getRandomGame
} from './api/web-services/gamesAPI'

import Layout from '../components/Layout'
import SuggestedContainer from '../components/user/SuggestedContainer'
import RecentlyAddedContainer from '../components/user/RecentlyAddedContainer'
import CommunautyRecoContainer from '../components/user/CommunautyRecoContainer'
import GameOfTheDayContainer from '../components/user/GameOfTheDayContainer'

export default function Home(data) {
  const { data: session, status } = useSession()

  // console.log(data.pageProps)
  // console.log(session)
  // console.log(status)

  return (
    <div>
      <Head>
        <title>My Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main>
        <Layout>
          <div className="">
            <GameOfTheDayContainer game={data.pageProps.gameOfTheDay} />
            <SuggestedContainer
              user={session && session}
              suggestedGames={data.pageProps.suggestedGames}
            />
            <RecentlyAddedContainer
              recentlyAddedGames={data.pageProps.recentlyAddedGames}
            />
            <CommunautyRecoContainer
              communautyReco={data.pageProps.communityRecommendedGames}
            />
          </div>
        </Layout>
      </main>
      <footer></footer>
    </div>
  )
}

export async function getServerSideProps(context) {
  const session = await getSession({ req: context.req })
  // console.log(session)

  const recentlyAddedPlatform = context?.query?.platform || 'all'

  const userEmail = session?.user?.email || ''

  const client = await connectToDataBase()
  const userCollection = client.db().collection('users')
  const user = await userCollection.findOne({ email: userEmail })

  // ********************************
  // *** SUGGESTED GAMES ***
  const data = user?.games_collection || [
    { genre: 'mmorpg' },
    { genre: 'shooter' }
  ]

  const genresAvailableTemp = []
  const userGenresAvailable = [...data].map((item) => {
    genresAvailableTemp.push(item.genre)
  })

  function classementRedondance(myArray) {
    // Créer un objet pour stocker la fréquence de chaque élément
    const frequencies = {}
    myArray.forEach((element) => {
      if (frequencies[element]) {
        frequencies[element]++
      } else {
        frequencies[element] = 1
      }
    })

    // Trier les éléments en fonction de leur fréquence (du plus grand au plus petit)
    const sortedElements = Object.keys(frequencies).sort(
      (a, b) => frequencies[b] - frequencies[a]
    )

    // Retourner les deux premiers éléments (ou tous les éléments s'il y en a moins de deux)
    return sortedElements.slice(0, 2).join('.').toLowerCase()
  }

  const result = classementRedondance(genresAvailableTemp)
  // console.log(result)

  const apiData = await getSuggestedGames(result)
  const suggestedGames = apiData.slice(0, 3)

  // ********************************
  // *** RECENTLY ADDED GAMES ***
  const getRecentlyAddedGames = await getAllGames(
    recentlyAddedPlatform,
    'all',
    'release-date'
  )
  const recentlyAddedGames = getRecentlyAddedGames.slice(0, 8)

  // ********************************
  // *** COMMUNAUTY RECOMMENDED GAMES ***
  const getGamesNotations = client.db().collection('notations')
  const gamesNotations = await getGamesNotations.find({}).toArray()

  // console.log(gamesNotations)

  function sortByVotes(array) {
    const scoreMap = { 1: -10, 2: 0, 3: 10 }

    // Ajouter un score à chaque élément
    const elementsWithScores = array.map((element) => {
      const totalScore = element.asVoted.flat().reduce((acc, vote) => {
        const note = vote.note
        return acc + (scoreMap[note] || 0)
      }, 0)

      return { element, totalScore }
    })

    // Trier les éléments par nombre d'éléments dans asVoted, puis par score
    const sortedElements = elementsWithScores.sort((a, b) => {
      if (a.element.asVoted.length !== b.element.asVoted.length) {
        return b.element.asVoted.length - a.element.asVoted.length
      }
      return b.totalScore - a.totalScore
    })

    // Retourner uniquement les éléments triés
    return sortedElements.map((elementWithScore) => elementWithScore.element)
  }

  const communityGames = JSON.parse(
    JSON.stringify(sortByVotes(gamesNotations).slice(0, 2))
  )

  const communityRecommendedGamesIds = communityGames.map((id) => id.gameId)
  const recoGameOne = await getGame(parseInt(communityRecommendedGamesIds[0]))
  const recoGameTwo = await getGame(parseInt(communityRecommendedGamesIds[1]))

  const recoGameOneComment = await client
    .db()
    .collection('comments')
    .findOne({ gameId: communityRecommendedGamesIds[0] })
  let comments = []
  if (recoGameOneComment) {
    comments = JSON.parse(
      JSON.stringify(recoGameOneComment.comments_collection)
    )
  } else {
    comments = null
  }

  const recoGameTwoComment = await client
    .db()
    .collection('comments')
    .findOne({ gameId: communityRecommendedGamesIds[1] })
  let comments2 = []
  if (recoGameTwoComment) {
    comments2 = JSON.parse(
      JSON.stringify(recoGameTwoComment.comments_collection)
    )
  } else {
    comments2 = null
  }

  try {
    recoGameOne.comment = recoGameOneComment.comments_collection[0].content
    recoGameOne.commentAuthor =
      recoGameOneComment.comments_collection[0].createdBy
  } catch (error) {
    recoGameOne.comment = 'no body'
    recoGameOne.commentAuthor = 'no commented yet'
  }

  try {
    recoGameTwo.comment = recoGameTwoComment.comments_collection[0].content
    recoGameTwo.commentAuthor =
      recoGameTwoComment.comments_collection[0].createdBy
  } catch (error) {
    recoGameTwo.comment = 'no body'
    recoGameTwo.commentAuthor = 'no commented yet'
  }

  const communityRecommendedGames = []
  communityRecommendedGames[0] = recoGameOne
  communityRecommendedGames[1] = recoGameTwo

  // ********************************
  // *** GAME OF THE DAY ***

  const gameOfTheDay = await getRandomGame()

  return {
    props: {
      suggestedGames,
      recentlyAddedGames,
      communityRecommendedGames,
      gameOfTheDay
    }
  }
}
