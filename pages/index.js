/* eslint-disable @next/next/no-img-element */
import React, { useContext, useEffect, useState } from 'react'
import Head from 'next/head'
import { useSession, getSession } from 'next-auth/react'

import { connectToDataBase } from '../lib/db'
import {
  getSuggestedGames,
  getAllGames,
  getGame,
  getRandomGame
} from './api/web-services/gamesAPI'
import {
  getVideoByGameName,
  getArtworksByGameName
} from './api/web-services/igbdAPI'

import Context from '../components/context/appContext'
import Hero from '../components/Hero'
import SuggestedContainer from '../components/games/SuggestedContainer'
import RecentlyAddedContainer from '../components/user/RecentlyAddedContainer'
import CommunautyRecoContainer from '../components/games/CommunautyRecoContainer'
import GameOfTheDayContainer from '../components/games/GameOfTheDayContainer'

export default function Home(data) {
  const { data: session, status } = useSession()
  const { bgImage, setBgImage } = useContext(Context)
  const [toggleBrowseGame, setToggleBrowseGame] = useState(false)

  // console.log(data.pageProps)
  // console.log(data.pageProps.gameOfTheDayArtworks)
  // console.log(session)
  // console.log(status)

  console.log('Temps de chargement de la page :', data.pageProps.loadTime, 'ms')

  useEffect(() => {
    if (data.pageProps.gameOfTheDayArtworks.artworks !== 'no data') {
      setBgImage(data.pageProps.gameOfTheDayArtworks.artworks)
      return
    } else {
      setBgImage('/images/default_bg.jpg')
    }
  }, [bgImage, setBgImage, data.pageProps.gameOfTheDayArtworks])

  const handleBrowseGame = () => {
    setToggleBrowseGame(!toggleBrowseGame)
  }

  return (
    <div className="">
      <Head>
        <title>Free Game App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      {!session && (
        <div
          className={` ${
            !toggleBrowseGame
              ? 'h-64 opacity-100 transition-all duration-500'
              : 'h-0 opacity-0 transition-all duration-500'
          }`}
        >
          <Hero onClick={handleBrowseGame} />
        </div>
      )}

      <main className="container mx-auto px-2 xl:px-4">
        <div>
          <GameOfTheDayContainer game={data.pageProps.gameOfTheDay} />
        </div>

        <div className="mt-10">
          <SuggestedContainer
            user={session && session}
            suggestedGames={data.pageProps.suggestedGames}
          />
        </div>
        <RecentlyAddedContainer
          recentlyAddedGames={data.pageProps.recentlyAddedGames}
        />
        <CommunautyRecoContainer
          communautyReco={data.pageProps.communityRecommendedGames}
        />
      </main>
      <footer></footer>
    </div>
  )
}

export async function getServerSideProps(context) {
  const startTime = performance.now()
  const session = await getSession({ req: context.req })
  // console.log(session)

  const recentlyAddedPlatform = context?.query?.platform || 'all'

  const userEmail = session?.user?.email || ''

  const client = await connectToDataBase()
  const userCollection = client.db().collection('users')
  const user = await userCollection.findOne({ email: userEmail })

  // ********************************
  // *** SUGGESTED GAMES ***
  const data = user?.games_collection || [
    { genre: 'mmorpg' },
    { genre: 'shooter' }
  ]

  const genresAvailableTemp = []
  const userGenresAvailable = [...data].map((item) => {
    genresAvailableTemp.push(item.genre)
  })

  function classementRedondance(myArray) {
    // Créer un objet pour stocker la fréquence de chaque élément
    const frequencies = {}
    myArray.forEach((element) => {
      if (frequencies[element]) {
        frequencies[element]++
      } else {
        frequencies[element] = 1
      }
    })

    // Trier les éléments en fonction de leur fréquence (du plus grand au plus petit)
    const sortedElements = Object.keys(frequencies).sort(
      (a, b) => frequencies[b] - frequencies[a]
    )

    // Retourner les deux premiers éléments (ou tous les éléments s'il y en a moins de deux)
    return sortedElements.slice(0, 2).join('.').toLowerCase()
  }

  const result = classementRedondance(genresAvailableTemp)

  const suggestedGames = await getSuggestedGames(result, 4)

  // ********************************
  // *** SUGGESTED GAMES => ADD ONE VIDEO (by game) ***

  let media = null
  for (let i = 0; i < suggestedGames.length; i++) {
    let currentGameTitle = suggestedGames[i].title
    try {
      media = await getVideoByGameName(currentGameTitle)
      if (media.video !== undefined) {
        suggestedGames[i]['video'] = media.video
      } else {
        suggestedGames[i]['video'] = null
      }
    } catch (error) {
      console.error(error)
    }
  }

  // ********************************
  // *** RECENTLY ADDED GAMES ***
  const getRecentlyAddedGames = await getAllGames(
    recentlyAddedPlatform,
    'all',
    'release-date',
    8
  )
  const recentlyAddedGames = getRecentlyAddedGames

  // ********************************
  // *** COMMUNAUTY RECOMMENDED GAMES ***
  const getGamesNotations = client.db().collection('notations')
  const gamesNotations = await getGamesNotations.find({}).toArray()

  // console.log(gamesNotations)

  function sortByVotes(array) {
    const scoreMap = { 1: -10, 2: 0, 3: 10 }

    // Ajouter un score à chaque élément
    const elementsWithScores = array.map((element) => {
      const totalScore = element.asVoted.flat().reduce((acc, vote) => {
        const note = vote.note
        return acc + (scoreMap[note] || 0)
      }, 0)

      return { element, totalScore }
    })

    // Trier les éléments par nombre d'éléments dans asVoted, puis par score
    const sortedElements = elementsWithScores.sort((a, b) => {
      if (a.element.asVoted.length !== b.element.asVoted.length) {
        return b.element.asVoted.length - a.element.asVoted.length
      }
      return b.totalScore - a.totalScore
    })

    // Retourner uniquement les éléments triés
    return sortedElements.map((elementWithScore) => elementWithScore.element)
  }

  const communityGames = JSON.parse(
    JSON.stringify(sortByVotes(gamesNotations).slice(0, 2))
  )

  const communityRecommendedGamesIds = communityGames.map((id) => id.gameId)
  const recoGameOne = await getGame(parseInt(communityRecommendedGamesIds[0]))
  const recoGameTwo = await getGame(parseInt(communityRecommendedGamesIds[1]))

  const recoGameOneComment = await client
    .db()
    .collection('comments')
    .findOne({ gameId: communityRecommendedGamesIds[0] })
  let comments = []
  if (recoGameOneComment) {
    comments = JSON.parse(
      JSON.stringify(recoGameOneComment.comments_collection)
    )
  } else {
    comments = null
  }

  const recoGameTwoComment = await client
    .db()
    .collection('comments')
    .findOne({ gameId: communityRecommendedGamesIds[1] })
  let comments2 = []
  if (recoGameTwoComment) {
    comments2 = JSON.parse(
      JSON.stringify(recoGameTwoComment.comments_collection)
    )
  } else {
    comments2 = null
  }

  try {
    recoGameOne.comment = recoGameOneComment.comments_collection[0].content
    recoGameOne.commentAuthor =
      recoGameOneComment.comments_collection[0].createdBy
  } catch (error) {
    recoGameOne.comment = 'no body'
    recoGameOne.commentAuthor = 'no commented yet'
  }

  try {
    recoGameTwo.comment = recoGameTwoComment.comments_collection[0].content
    recoGameTwo.commentAuthor =
      recoGameTwoComment.comments_collection[0].createdBy
  } catch (error) {
    recoGameTwo.comment = 'no body'
    recoGameTwo.commentAuthor = 'no commented yet'
  }

  const communityRecommendedGames = []
  communityRecommendedGames[0] = recoGameOne
  communityRecommendedGames[1] = recoGameTwo

  // ********************************
  // *** GAME OF THE DAY ***
  let arrayOfIds = []
  const gameOfTheDay = await getRandomGame()

  const gamesOfTheDayIds = gameOfTheDay.filter((item) =>
    arrayOfIds.push(item.id)
  )

  for (let i = 0; i < 2; i++) {
    let owners = []
    const existingOwners = await client
      .db()
      .collection('gamesOwners')
      .findOne({ gameId: arrayOfIds[i] })

    if (existingOwners) {
      owners = JSON.parse(JSON.stringify(existingOwners.owners))
    } else {
      owners = null
    }

    const gameOwners = owners ? owners.length : 0
    gameOfTheDay[i]['owners'] = gameOwners
  }

  // ********************************
  // *** ARTWORKS FROM GAME OF THE DAY ***

  let gameOfTheDayArtworks =
    (await getArtworksByGameName(gameOfTheDay[0].title)) || null

  const endTime = performance.now()
  const loadTime = endTime - startTime
  // console.log('Temps de chargement de la page :', loadTime, 'ms')

  return {
    props: {
      suggestedGames,
      recentlyAddedGames,
      communityRecommendedGames,
      gameOfTheDay,
      gameOfTheDayArtworks,
      loadTime
    }
  }
}
